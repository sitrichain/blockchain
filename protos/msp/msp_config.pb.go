// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: msp_config.proto

package msp

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MSPConfig collects all the configuration information for
// an MSP. The Config field should be unmarshalled in a way
// that depends on the Type
type MSPConfig struct {
	// Type holds the type of the MSP; the default one would
	// be of type FABRIC implementing an X.509 based provider
	Type int32 `protobuf:"varint,1,opt,name=type,proto3" json:"type,omitempty"`
	// Config is MSP dependent configuration info
	Config               []byte   `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MSPConfig) Reset()         { *m = MSPConfig{} }
func (m *MSPConfig) String() string { return proto.CompactTextString(m) }
func (*MSPConfig) ProtoMessage()    {}
func (*MSPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1cbdb818a978d24, []int{0}
}
func (m *MSPConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MSPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MSPConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MSPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MSPConfig.Merge(m, src)
}
func (m *MSPConfig) XXX_Size() int {
	return m.Size()
}
func (m *MSPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_MSPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_MSPConfig proto.InternalMessageInfo

func (m *MSPConfig) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *MSPConfig) GetConfig() []byte {
	if m != nil {
		return m.Config
	}
	return nil
}

// BlockchainMSPConfig collects all the configuration information for
// a Blockchain MSP.
// Here we assume a default certificate validation policy, where
// any certificate signed by any of the listed rootCA certs would
// be considered as valid under this MSP.
// This MSP may or may not come with a signing identity. If it does,
// it can also issue signing identities. If it does not, it can only
// be used to validate and verify certificates.
type BlockchainMSPConfig struct {
	// Name holds the identifier of the MSP; MSP identifier
	// is chosen by the application that governs this MSP.
	// For example, and assuming the default implementation of MSP,
	// that is X.509-based and considers a single Issuer,
	// this can refer to the Subject OU field or the Issuer OU field.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// List of root certificates trusted by this MSP
	// they are used upon certificate validation (see
	// comment for IntermediateCerts below)
	RootCerts [][]byte `protobuf:"bytes,2,rep,name=root_certs,json=rootCerts,proto3" json:"root_certs,omitempty"`
	// List of intermediate certificates trusted by this MSP;
	// they are used upon certificate validation as follows:
	// validation attempts to build a path from the certificate
	// to be validated (which is at one end of the path) and
	// one of the certs in the RootCerts field (which is at
	// the other end of the path). If the path is longer than
	// 2, certificates in the middle are searched within the
	// IntermediateCerts pool
	IntermediateCerts [][]byte `protobuf:"bytes,3,rep,name=intermediate_certs,json=intermediateCerts,proto3" json:"intermediate_certs,omitempty"`
	// Identity denoting the administrator of this MSP
	Admins [][]byte `protobuf:"bytes,4,rep,name=admins,proto3" json:"admins,omitempty"`
	// Identity revocation list
	RevocationList [][]byte `protobuf:"bytes,5,rep,name=revocation_list,json=revocationList,proto3" json:"revocation_list,omitempty"`
	// SigningIdentity holds information on the signing identity
	// this peer is to use, and which is to be imported by the
	// MSP defined before
	SigningIdentity *SigningIdentityInfo `protobuf:"bytes,6,opt,name=signing_identity,json=signingIdentity,proto3" json:"signing_identity,omitempty"`
	// OrganizationalUnitIdentifiers holds one or more
	// fabric organizational unit identifiers that belong to
	// this MSP configuration
	OrganizationalUnitIdentifiers []*BlockchainOUIdentifier `protobuf:"bytes,7,rep,name=organizational_unit_identifiers,json=organizationalUnitIdentifiers,proto3" json:"organizational_unit_identifiers,omitempty"`
	// BlockchainCryptoConfig contains the configuration parameters
	// for the cryptographic algorithms used by this MSP
	CryptoConfig *BlockchainCryptoConfig `protobuf:"bytes,8,opt,name=crypto_config,json=cryptoConfig,proto3" json:"crypto_config,omitempty"`
	// List of TLS root certificates trusted by this MSP.
	// They are returned by GetTLSRootCerts.
	TlsRootCerts [][]byte `protobuf:"bytes,9,rep,name=tls_root_certs,json=tlsRootCerts,proto3" json:"tls_root_certs,omitempty"`
	// List of TLS intermediate certificates trusted by this MSP;
	// They are returned by GetTLSIntermediateCerts.
	TlsIntermediateCerts [][]byte `protobuf:"bytes,10,rep,name=tls_intermediate_certs,json=tlsIntermediateCerts,proto3" json:"tls_intermediate_certs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BlockchainMSPConfig) Reset()         { *m = BlockchainMSPConfig{} }
func (m *BlockchainMSPConfig) String() string { return proto.CompactTextString(m) }
func (*BlockchainMSPConfig) ProtoMessage()    {}
func (*BlockchainMSPConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1cbdb818a978d24, []int{1}
}
func (m *BlockchainMSPConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockchainMSPConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockchainMSPConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockchainMSPConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockchainMSPConfig.Merge(m, src)
}
func (m *BlockchainMSPConfig) XXX_Size() int {
	return m.Size()
}
func (m *BlockchainMSPConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockchainMSPConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BlockchainMSPConfig proto.InternalMessageInfo

func (m *BlockchainMSPConfig) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BlockchainMSPConfig) GetRootCerts() [][]byte {
	if m != nil {
		return m.RootCerts
	}
	return nil
}

func (m *BlockchainMSPConfig) GetIntermediateCerts() [][]byte {
	if m != nil {
		return m.IntermediateCerts
	}
	return nil
}

func (m *BlockchainMSPConfig) GetAdmins() [][]byte {
	if m != nil {
		return m.Admins
	}
	return nil
}

func (m *BlockchainMSPConfig) GetRevocationList() [][]byte {
	if m != nil {
		return m.RevocationList
	}
	return nil
}

func (m *BlockchainMSPConfig) GetSigningIdentity() *SigningIdentityInfo {
	if m != nil {
		return m.SigningIdentity
	}
	return nil
}

func (m *BlockchainMSPConfig) GetOrganizationalUnitIdentifiers() []*BlockchainOUIdentifier {
	if m != nil {
		return m.OrganizationalUnitIdentifiers
	}
	return nil
}

func (m *BlockchainMSPConfig) GetCryptoConfig() *BlockchainCryptoConfig {
	if m != nil {
		return m.CryptoConfig
	}
	return nil
}

func (m *BlockchainMSPConfig) GetTlsRootCerts() [][]byte {
	if m != nil {
		return m.TlsRootCerts
	}
	return nil
}

func (m *BlockchainMSPConfig) GetTlsIntermediateCerts() [][]byte {
	if m != nil {
		return m.TlsIntermediateCerts
	}
	return nil
}

// BlockchainCryptoConfig contains configuration parameters
// for the cryptographic algorithms used by the MSP
// this configuration refers to
type BlockchainCryptoConfig struct {
	// SignatureHashFamily is a string representing the hash family to be used
	// during sign and verify operations.
	// Allowed values are "SHA2" and "SHA3".
	SignatureHashFamily string `protobuf:"bytes,1,opt,name=signature_hash_family,json=signatureHashFamily,proto3" json:"signature_hash_family,omitempty"`
	// IdentityIdentifierHashFunction is a string representing the hash function
	// to be used during the computation of the identity identifier of an MSP identity.
	// Allowed values are "SHA256", "SHA384" and "SHA3_256", "SHA3_384".
	IdentityIdentifierHashFunction string   `protobuf:"bytes,2,opt,name=identity_identifier_hash_function,json=identityIdentifierHashFunction,proto3" json:"identity_identifier_hash_function,omitempty"`
	XXX_NoUnkeyedLiteral           struct{} `json:"-"`
	XXX_unrecognized               []byte   `json:"-"`
	XXX_sizecache                  int32    `json:"-"`
}

func (m *BlockchainCryptoConfig) Reset()         { *m = BlockchainCryptoConfig{} }
func (m *BlockchainCryptoConfig) String() string { return proto.CompactTextString(m) }
func (*BlockchainCryptoConfig) ProtoMessage()    {}
func (*BlockchainCryptoConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1cbdb818a978d24, []int{2}
}
func (m *BlockchainCryptoConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockchainCryptoConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockchainCryptoConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockchainCryptoConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockchainCryptoConfig.Merge(m, src)
}
func (m *BlockchainCryptoConfig) XXX_Size() int {
	return m.Size()
}
func (m *BlockchainCryptoConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockchainCryptoConfig.DiscardUnknown(m)
}

var xxx_messageInfo_BlockchainCryptoConfig proto.InternalMessageInfo

func (m *BlockchainCryptoConfig) GetSignatureHashFamily() string {
	if m != nil {
		return m.SignatureHashFamily
	}
	return ""
}

func (m *BlockchainCryptoConfig) GetIdentityIdentifierHashFunction() string {
	if m != nil {
		return m.IdentityIdentifierHashFunction
	}
	return ""
}

// SigningIdentityInfo represents the configuration information
// related to the signing identity the peer is to use for generating
// endorsements
type SigningIdentityInfo struct {
	// PublicSigner carries the public information of the signing
	// identity. For an X.509 provider this would be represented by
	// an X.509 certificate
	PublicSigner []byte `protobuf:"bytes,1,opt,name=public_signer,json=publicSigner,proto3" json:"public_signer,omitempty"`
	// PrivateSigner denotes a reference to the private key of the
	// peer's signing identity
	PrivateSigner        *KeyInfo `protobuf:"bytes,2,opt,name=private_signer,json=privateSigner,proto3" json:"private_signer,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SigningIdentityInfo) Reset()         { *m = SigningIdentityInfo{} }
func (m *SigningIdentityInfo) String() string { return proto.CompactTextString(m) }
func (*SigningIdentityInfo) ProtoMessage()    {}
func (*SigningIdentityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1cbdb818a978d24, []int{3}
}
func (m *SigningIdentityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SigningIdentityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SigningIdentityInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SigningIdentityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningIdentityInfo.Merge(m, src)
}
func (m *SigningIdentityInfo) XXX_Size() int {
	return m.Size()
}
func (m *SigningIdentityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningIdentityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SigningIdentityInfo proto.InternalMessageInfo

func (m *SigningIdentityInfo) GetPublicSigner() []byte {
	if m != nil {
		return m.PublicSigner
	}
	return nil
}

func (m *SigningIdentityInfo) GetPrivateSigner() *KeyInfo {
	if m != nil {
		return m.PrivateSigner
	}
	return nil
}

// KeyInfo represents a (secret) key that is either already stored
// in the bccsp/keystore or key material to be imported to the
// bccsp key-store. In later versions it may contain also a
// keystore identifier
type KeyInfo struct {
	// Identifier of the key inside the default keystore; this for
	// the case of Software BCCSP as well as the HSM BCCSP would be
	// the SKI of the key
	KeyIdentifier string `protobuf:"bytes,1,opt,name=key_identifier,json=keyIdentifier,proto3" json:"key_identifier,omitempty"`
	// KeyMaterial (optional) for the key to be imported; this is
	// properly encoded key bytes, prefixed by the type of the key
	KeyMaterial          []byte   `protobuf:"bytes,2,opt,name=key_material,json=keyMaterial,proto3" json:"key_material,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyInfo) Reset()         { *m = KeyInfo{} }
func (m *KeyInfo) String() string { return proto.CompactTextString(m) }
func (*KeyInfo) ProtoMessage()    {}
func (*KeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1cbdb818a978d24, []int{4}
}
func (m *KeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyInfo.Merge(m, src)
}
func (m *KeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *KeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KeyInfo proto.InternalMessageInfo

func (m *KeyInfo) GetKeyIdentifier() string {
	if m != nil {
		return m.KeyIdentifier
	}
	return ""
}

func (m *KeyInfo) GetKeyMaterial() []byte {
	if m != nil {
		return m.KeyMaterial
	}
	return nil
}

// BlockchainOUIdentifier represents an organizational unit and
// its related chain of trust identifier.
type BlockchainOUIdentifier struct {
	// Certificate represents the second certificate in a certification chain.
	// (Notice that the first certificate in a certification chain is supposed
	// to be the certificate of an identity).
	// It must correspond to the certificate of root or intermediate CA
	// recognized by the MSP this message belongs to.
	// Starting from this certificate, a certification chain is computed
	// and boud to the OrganizationUnitIdentifier specified
	Certificate []byte `protobuf:"bytes,1,opt,name=certificate,proto3" json:"certificate,omitempty"`
	// OrganizationUnitIdentifier defines the organizational unit under the
	// MSP identified with MSPIdentifier
	OrganizationalUnitIdentifier string   `protobuf:"bytes,2,opt,name=organizational_unit_identifier,json=organizationalUnitIdentifier,proto3" json:"organizational_unit_identifier,omitempty"`
	XXX_NoUnkeyedLiteral         struct{} `json:"-"`
	XXX_unrecognized             []byte   `json:"-"`
	XXX_sizecache                int32    `json:"-"`
}

func (m *BlockchainOUIdentifier) Reset()         { *m = BlockchainOUIdentifier{} }
func (m *BlockchainOUIdentifier) String() string { return proto.CompactTextString(m) }
func (*BlockchainOUIdentifier) ProtoMessage()    {}
func (*BlockchainOUIdentifier) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1cbdb818a978d24, []int{5}
}
func (m *BlockchainOUIdentifier) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockchainOUIdentifier) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockchainOUIdentifier.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockchainOUIdentifier) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockchainOUIdentifier.Merge(m, src)
}
func (m *BlockchainOUIdentifier) XXX_Size() int {
	return m.Size()
}
func (m *BlockchainOUIdentifier) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockchainOUIdentifier.DiscardUnknown(m)
}

var xxx_messageInfo_BlockchainOUIdentifier proto.InternalMessageInfo

func (m *BlockchainOUIdentifier) GetCertificate() []byte {
	if m != nil {
		return m.Certificate
	}
	return nil
}

func (m *BlockchainOUIdentifier) GetOrganizationalUnitIdentifier() string {
	if m != nil {
		return m.OrganizationalUnitIdentifier
	}
	return ""
}

func init() {
	proto.RegisterType((*MSPConfig)(nil), "msp.MSPConfig")
	proto.RegisterType((*BlockchainMSPConfig)(nil), "msp.BlockchainMSPConfig")
	proto.RegisterType((*BlockchainCryptoConfig)(nil), "msp.BlockchainCryptoConfig")
	proto.RegisterType((*SigningIdentityInfo)(nil), "msp.SigningIdentityInfo")
	proto.RegisterType((*KeyInfo)(nil), "msp.KeyInfo")
	proto.RegisterType((*BlockchainOUIdentifier)(nil), "msp.BlockchainOUIdentifier")
}

func init() { proto.RegisterFile("msp_config.proto", fileDescriptor_a1cbdb818a978d24) }

var fileDescriptor_a1cbdb818a978d24 = []byte{
	// 616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0x51, 0x6f, 0xd3, 0x3c,
	0x14, 0x55, 0xd6, 0xad, 0xfb, 0x7a, 0x9b, 0x76, 0xfb, 0x3c, 0xa8, 0x22, 0xc1, 0x4a, 0x17, 0x40,
	0xe4, 0x85, 0x54, 0xda, 0x90, 0x78, 0x45, 0x2b, 0x42, 0x54, 0x30, 0x31, 0xa5, 0xda, 0x0b, 0x2f,
	0x91, 0xeb, 0xb9, 0xa9, 0x95, 0xc4, 0x8e, 0x6c, 0x77, 0x52, 0xf7, 0xb4, 0x7f, 0xc1, 0x5f, 0xe2,
	0x91, 0x9f, 0x80, 0xf6, 0x4b, 0x50, 0x1c, 0xaf, 0x4d, 0xa7, 0x6a, 0x6f, 0xf6, 0xb9, 0xe7, 0x9e,
	0x5e, 0x9f, 0x73, 0x1b, 0x38, 0xcc, 0x55, 0x11, 0x13, 0xc1, 0x67, 0x2c, 0x09, 0x0b, 0x29, 0xb4,
	0x40, 0x8d, 0x5c, 0x15, 0xfe, 0x47, 0x68, 0x5d, 0x4c, 0x2e, 0x47, 0x06, 0x47, 0x08, 0x76, 0xf5,
	0xb2, 0xa0, 0x9e, 0x33, 0x70, 0x82, 0xbd, 0xc8, 0x9c, 0x51, 0x0f, 0x9a, 0x55, 0x97, 0xb7, 0x33,
	0x70, 0x02, 0x37, 0xb2, 0x37, 0xff, 0x6e, 0x17, 0x8e, 0xce, 0x33, 0x41, 0x52, 0x32, 0xc7, 0x8c,
	0x6f, 0x68, 0x70, 0x9c, 0x57, 0x1a, 0xad, 0xc8, 0x9c, 0xd1, 0x31, 0x80, 0x14, 0x42, 0xc7, 0x84,
	0x4a, 0xad, 0xbc, 0x9d, 0x41, 0x23, 0x70, 0xa3, 0x56, 0x89, 0x8c, 0x4a, 0x00, 0xbd, 0x07, 0xc4,
	0xb8, 0xa6, 0x32, 0xa7, 0xd7, 0x0c, 0x6b, 0x6a, 0x69, 0x0d, 0x43, 0xfb, 0xbf, 0x5e, 0xa9, 0xe8,
	0x3d, 0x68, 0xe2, 0xeb, 0x9c, 0x71, 0xe5, 0xed, 0x1a, 0x8a, 0xbd, 0xa1, 0x77, 0x70, 0x20, 0xe9,
	0x8d, 0x20, 0x58, 0x33, 0xc1, 0xe3, 0x8c, 0x29, 0xed, 0xed, 0x19, 0x42, 0x77, 0x0d, 0x7f, 0x67,
	0x4a, 0xa3, 0x11, 0x1c, 0x2a, 0x96, 0x70, 0xc6, 0x93, 0x98, 0x5d, 0x53, 0xae, 0x99, 0x5e, 0x7a,
	0xcd, 0x81, 0x13, 0xb4, 0x4f, 0xbd, 0x30, 0x57, 0x45, 0x38, 0xa9, 0x8a, 0x63, 0x5b, 0x1b, 0xf3,
	0x99, 0x88, 0x0e, 0xd4, 0x26, 0x88, 0x08, 0xbc, 0x12, 0x32, 0xc1, 0x9c, 0xdd, 0x1a, 0x61, 0x9c,
	0xc5, 0x0b, 0xce, 0xb4, 0x15, 0x9c, 0x31, 0x2a, 0x95, 0xb7, 0x3f, 0x68, 0x04, 0xed, 0xd3, 0x17,
	0x46, 0x73, 0x6d, 0xd5, 0x8f, 0xab, 0xf1, 0x8a, 0x13, 0x1d, 0x6f, 0x6a, 0x5c, 0x71, 0xa6, 0xd7,
	0x55, 0x85, 0x3e, 0x41, 0x87, 0xc8, 0x65, 0xa1, 0x85, 0x4d, 0xce, 0xfb, 0xcf, 0x8c, 0xf9, 0x58,
	0x72, 0x64, 0x38, 0x55, 0x00, 0x91, 0x4b, 0x6a, 0x37, 0xf4, 0x06, 0xba, 0x3a, 0x53, 0x71, 0xcd,
	0xfe, 0x96, 0xf1, 0xc4, 0xd5, 0x99, 0x8a, 0x56, 0x09, 0x7c, 0x80, 0x5e, 0xc9, 0xda, 0x92, 0x02,
	0x18, 0xf6, 0x33, 0x9d, 0xa9, 0xf1, 0xe3, 0x20, 0xfc, 0x5f, 0x0e, 0xf4, 0xb6, 0x0f, 0x81, 0x4e,
	0xe1, 0x79, 0x69, 0x18, 0xd6, 0x0b, 0x49, 0xe3, 0x39, 0x56, 0xf3, 0x78, 0x86, 0x73, 0x96, 0x2d,
	0xed, 0x5a, 0x1c, 0xad, 0x8a, 0x5f, 0xb1, 0x9a, 0x7f, 0x31, 0x25, 0x34, 0x86, 0x93, 0x87, 0x38,
	0x6a, 0x36, 0xda, 0xee, 0x05, 0x27, 0xa5, 0x45, 0x66, 0x09, 0x5b, 0x51, 0xff, 0x81, 0xb8, 0x36,
	0xcb, 0x08, 0x59, 0x96, 0x2f, 0xe0, 0x68, 0x4b, 0x88, 0xe8, 0x35, 0x74, 0x8a, 0xc5, 0x34, 0x63,
	0x24, 0x2e, 0x7f, 0x9f, 0x4a, 0x33, 0x8d, 0x1b, 0xb9, 0x15, 0x38, 0x31, 0x18, 0x3a, 0x83, 0x6e,
	0x21, 0xd9, 0x4d, 0x69, 0x81, 0x65, 0xed, 0x18, 0xd3, 0x5d, 0x63, 0xfa, 0x37, 0x5a, 0xed, 0x43,
	0xc7, 0x72, 0xaa, 0x26, 0x7f, 0x02, 0xfb, 0xb6, 0x82, 0xde, 0x42, 0x37, 0xa5, 0xf5, 0x17, 0xd8,
	0x37, 0x77, 0x52, 0x5a, 0x1b, 0x17, 0x9d, 0x80, 0x5b, 0xd2, 0x72, 0xac, 0xa9, 0x64, 0x38, 0xb3,
	0xff, 0xae, 0x76, 0x4a, 0x97, 0x17, 0x16, 0xf2, 0xef, 0x36, 0xfc, 0xad, 0xef, 0x0d, 0x1a, 0x40,
	0xbb, 0xcc, 0x87, 0xcd, 0x18, 0xc1, 0x9a, 0xda, 0x77, 0xd4, 0x21, 0xf4, 0x19, 0xfa, 0x4f, 0xef,
	0xa7, 0xb5, 0xf2, 0xe5, 0x53, 0x1b, 0x78, 0x9e, 0xfe, 0xbe, 0xef, 0x3b, 0x7f, 0xee, 0xfb, 0xce,
	0xdf, 0xfb, 0xbe, 0x03, 0x27, 0x44, 0xe4, 0xa1, 0x14, 0x3c, 0xb9, 0xa5, 0x32, 0x9c, 0xae, 0x26,
	0xab, 0xbe, 0x27, 0xaa, 0xf4, 0xe7, 0xfc, 0xf0, 0x42, 0x15, 0xd5, 0x0e, 0x5c, 0x62, 0x92, 0xe2,
	0x84, 0xfe, 0x0c, 0x12, 0xa6, 0xe7, 0x8b, 0x69, 0x48, 0x44, 0x3e, 0xb4, 0xbd, 0xc3, 0x75, 0xef,
	0xb0, 0xea, 0x1d, 0xe6, 0xaa, 0x98, 0x36, 0xcd, 0xf9, 0xec, 0x5f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x28, 0x7f, 0x55, 0x29, 0xab, 0x04, 0x00, 0x00,
}

func (m *MSPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MSPConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MSPConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintMspConfig(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockchainMSPConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockchainMSPConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockchainMSPConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TlsIntermediateCerts) > 0 {
		for iNdEx := len(m.TlsIntermediateCerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsIntermediateCerts[iNdEx])
			copy(dAtA[i:], m.TlsIntermediateCerts[iNdEx])
			i = encodeVarintMspConfig(dAtA, i, uint64(len(m.TlsIntermediateCerts[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.TlsRootCerts) > 0 {
		for iNdEx := len(m.TlsRootCerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TlsRootCerts[iNdEx])
			copy(dAtA[i:], m.TlsRootCerts[iNdEx])
			i = encodeVarintMspConfig(dAtA, i, uint64(len(m.TlsRootCerts[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.CryptoConfig != nil {
		{
			size, err := m.CryptoConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMspConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.OrganizationalUnitIdentifiers) > 0 {
		for iNdEx := len(m.OrganizationalUnitIdentifiers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OrganizationalUnitIdentifiers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMspConfig(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.SigningIdentity != nil {
		{
			size, err := m.SigningIdentity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMspConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.RevocationList) > 0 {
		for iNdEx := len(m.RevocationList) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RevocationList[iNdEx])
			copy(dAtA[i:], m.RevocationList[iNdEx])
			i = encodeVarintMspConfig(dAtA, i, uint64(len(m.RevocationList[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Admins) > 0 {
		for iNdEx := len(m.Admins) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Admins[iNdEx])
			copy(dAtA[i:], m.Admins[iNdEx])
			i = encodeVarintMspConfig(dAtA, i, uint64(len(m.Admins[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.IntermediateCerts) > 0 {
		for iNdEx := len(m.IntermediateCerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IntermediateCerts[iNdEx])
			copy(dAtA[i:], m.IntermediateCerts[iNdEx])
			i = encodeVarintMspConfig(dAtA, i, uint64(len(m.IntermediateCerts[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RootCerts) > 0 {
		for iNdEx := len(m.RootCerts) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RootCerts[iNdEx])
			copy(dAtA[i:], m.RootCerts[iNdEx])
			i = encodeVarintMspConfig(dAtA, i, uint64(len(m.RootCerts[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockchainCryptoConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockchainCryptoConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockchainCryptoConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IdentityIdentifierHashFunction) > 0 {
		i -= len(m.IdentityIdentifierHashFunction)
		copy(dAtA[i:], m.IdentityIdentifierHashFunction)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.IdentityIdentifierHashFunction)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SignatureHashFamily) > 0 {
		i -= len(m.SignatureHashFamily)
		copy(dAtA[i:], m.SignatureHashFamily)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.SignatureHashFamily)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SigningIdentityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SigningIdentityInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SigningIdentityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PrivateSigner != nil {
		{
			size, err := m.PrivateSigner.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMspConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.PublicSigner) > 0 {
		i -= len(m.PublicSigner)
		copy(dAtA[i:], m.PublicSigner)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.PublicSigner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.KeyMaterial) > 0 {
		i -= len(m.KeyMaterial)
		copy(dAtA[i:], m.KeyMaterial)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.KeyMaterial)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.KeyIdentifier) > 0 {
		i -= len(m.KeyIdentifier)
		copy(dAtA[i:], m.KeyIdentifier)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.KeyIdentifier)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockchainOUIdentifier) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockchainOUIdentifier) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockchainOUIdentifier) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.OrganizationalUnitIdentifier) > 0 {
		i -= len(m.OrganizationalUnitIdentifier)
		copy(dAtA[i:], m.OrganizationalUnitIdentifier)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.OrganizationalUnitIdentifier)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintMspConfig(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMspConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovMspConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MSPConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMspConfig(uint64(m.Type))
	}
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockchainMSPConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if len(m.RootCerts) > 0 {
		for _, b := range m.RootCerts {
			l = len(b)
			n += 1 + l + sovMspConfig(uint64(l))
		}
	}
	if len(m.IntermediateCerts) > 0 {
		for _, b := range m.IntermediateCerts {
			l = len(b)
			n += 1 + l + sovMspConfig(uint64(l))
		}
	}
	if len(m.Admins) > 0 {
		for _, b := range m.Admins {
			l = len(b)
			n += 1 + l + sovMspConfig(uint64(l))
		}
	}
	if len(m.RevocationList) > 0 {
		for _, b := range m.RevocationList {
			l = len(b)
			n += 1 + l + sovMspConfig(uint64(l))
		}
	}
	if m.SigningIdentity != nil {
		l = m.SigningIdentity.Size()
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if len(m.OrganizationalUnitIdentifiers) > 0 {
		for _, e := range m.OrganizationalUnitIdentifiers {
			l = e.Size()
			n += 1 + l + sovMspConfig(uint64(l))
		}
	}
	if m.CryptoConfig != nil {
		l = m.CryptoConfig.Size()
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if len(m.TlsRootCerts) > 0 {
		for _, b := range m.TlsRootCerts {
			l = len(b)
			n += 1 + l + sovMspConfig(uint64(l))
		}
	}
	if len(m.TlsIntermediateCerts) > 0 {
		for _, b := range m.TlsIntermediateCerts {
			l = len(b)
			n += 1 + l + sovMspConfig(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockchainCryptoConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SignatureHashFamily)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	l = len(m.IdentityIdentifierHashFunction)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SigningIdentityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PublicSigner)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if m.PrivateSigner != nil {
		l = m.PrivateSigner.Size()
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyIdentifier)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	l = len(m.KeyMaterial)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockchainOUIdentifier) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	l = len(m.OrganizationalUnitIdentifier)
	if l > 0 {
		n += 1 + l + sovMspConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMspConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMspConfig(x uint64) (n int) {
	return sovMspConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MSPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MSPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MSPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], dAtA[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockchainMSPConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockchainMSPConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockchainMSPConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootCerts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootCerts = append(m.RootCerts, make([]byte, postIndex-iNdEx))
			copy(m.RootCerts[len(m.RootCerts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntermediateCerts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IntermediateCerts = append(m.IntermediateCerts, make([]byte, postIndex-iNdEx))
			copy(m.IntermediateCerts[len(m.IntermediateCerts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admins", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admins = append(m.Admins, make([]byte, postIndex-iNdEx))
			copy(m.Admins[len(m.Admins)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevocationList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevocationList = append(m.RevocationList, make([]byte, postIndex-iNdEx))
			copy(m.RevocationList[len(m.RevocationList)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningIdentity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SigningIdentity == nil {
				m.SigningIdentity = &SigningIdentityInfo{}
			}
			if err := m.SigningIdentity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationalUnitIdentifiers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationalUnitIdentifiers = append(m.OrganizationalUnitIdentifiers, &BlockchainOUIdentifier{})
			if err := m.OrganizationalUnitIdentifiers[len(m.OrganizationalUnitIdentifiers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CryptoConfig == nil {
				m.CryptoConfig = &BlockchainCryptoConfig{}
			}
			if err := m.CryptoConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsRootCerts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsRootCerts = append(m.TlsRootCerts, make([]byte, postIndex-iNdEx))
			copy(m.TlsRootCerts[len(m.TlsRootCerts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsIntermediateCerts", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TlsIntermediateCerts = append(m.TlsIntermediateCerts, make([]byte, postIndex-iNdEx))
			copy(m.TlsIntermediateCerts[len(m.TlsIntermediateCerts)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockchainCryptoConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockchainCryptoConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockchainCryptoConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureHashFamily", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignatureHashFamily = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityIdentifierHashFunction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityIdentifierHashFunction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SigningIdentityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SigningIdentityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SigningIdentityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicSigner", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicSigner = append(m.PublicSigner[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicSigner == nil {
				m.PublicSigner = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateSigner", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrivateSigner == nil {
				m.PrivateSigner = &KeyInfo{}
			}
			if err := m.PrivateSigner.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyMaterial", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyMaterial = append(m.KeyMaterial[:0], dAtA[iNdEx:postIndex]...)
			if m.KeyMaterial == nil {
				m.KeyMaterial = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockchainOUIdentifier) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMspConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockchainOUIdentifier: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockchainOUIdentifier: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate[:0], dAtA[iNdEx:postIndex]...)
			if m.Certificate == nil {
				m.Certificate = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationalUnitIdentifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMspConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMspConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationalUnitIdentifier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMspConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMspConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMspConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMspConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMspConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMspConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMspConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMspConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMspConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMspConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMspConfig = fmt.Errorf("proto: unexpected end of group")
)
